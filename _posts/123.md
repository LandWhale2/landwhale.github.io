---
title: "페이징 기법(2)"
date : 2020-10-22 21:19:30 -0400
categories: OS
---


# 페이징 기법 과정


## 주소변환(Address Translation)

페이징 기법을 사용하기 위해서는 여러 개로 흩어진 페이지에 CPU가 접근하기 위해서 페이지 테이블을 통해 주소를 변환해야 한다.

##### 논리 주소(Logical address)
```
CPU가 내는 주소는 2진수로 표현되고 이를 m비트가 있다고 가정하자. 

여기서 하위 n비트는 오프셋(offset) 또는 변위(displacement)라고 한다. 

그리고 상위 m-n 비트는 페이지의 번호에 해당한다.(n = d, m-n = p)
```



연속 메모리 할당을 하면서 외부 단편화가 발생하여 이를 해결하기 위해 페이징 기법이 나왔다. 

하지만 페이징은 외부 단편화가 아닌 내부 단편화가 발생한다.

## 내부단편화(Internal Fragment)

내부단편화는 프로세스 크기가 페이지 크기의 배수가 아닐 경우, 마지막 페이지는 한 프레임을 다 채울 수 없다. 이로 인해 발생하는 공간은 결국 메모리 낭비로 이어진다.

예를 들어, 15bytes 크기의 프로세스 P가 있다. 페이지 크기(프레임 크기)는 4bytes로 P를 페이지로 나누면 4, 4, 4, 3 의 크기로 총 4개의 페이지가 만들어진다. 

여기서 마지막 3bytes 페이지는 프레임 크기보다 1byte작으므로, 

이 만큼 메모리 공간이 비게 된다. 이렇게 비어진 공간은 프로세스 P에서도 쓰지 않고, 다른 프로세스에서도 쓰지 못하는 낭비되는 공간이 된다.

이 내부 단편화 문제는 해결할 방법이 없는데 최대 낭비되는 크기가 무시할정도로 작은 크기이기 때문에 괜찮다.


## 페이지 테이블 만들기

### CPU 내부에 만들기

페이지 테이블을 만드는 방법은 여러 가지가 있다. 먼저, CPU 내부에 페이지 테이블을 만들 수 있다. 

CPU 내부의 기억장치는 레지스터로, 여러 개의 레지스터로 페이지 테이블을 만드는 것이다. 

CPU 내부에 페이지 테이블을 만들면, 장점은 주소 변환 속도가 빠르다. 하지만 단점은 CPU 내부에 사용할 수 있는 레지스터는 한정되어 있으므로 페이지 테이블의 크기가 매우 제한된다.


### 메모리 내부에 만들기

페이지 테이블을 메모리 내부에서 만들 수도 있다. 메모리 내부에 만드는 것의 장단점은 CPU와 정 반대이다. 

즉, 장점은 페이지 테이블의 크기에 제한이 없는 것이고, 단점은 주소 변환 속도가 느리다는 것이다. 

CPU는 프로세스의 주소에 접근하기 위해서 메모리에 위치한 페이지 테이블에 한 번, 

실제 주소로 접근하는데 한 번해서 메모리에 총 2번 접근해야하므로 속도 역시 2배로 느려진다.


### 페이지 테이블 캐시

위의 두방법이 장단점이 확실하기 때문에 이를 해결하기위해 페이지 테이블도 캐시로 만들어 해결하였다. 

이지 테이블을 별도의 칩(SRAM)으로 만들어서 CPU와 메모리 사이에 위치시키는 것이다. 이러한 테이블을 TLB(Translation Look-aside Buffer) 라고 부른다.

이는 CPU보다 변환 속도는 느리고 메모리보다 테이블 크기는 작지만, CPU보다 테이블 크기가 크고 메모리보다 변환 속도가 빠르다.

## 보호와 공유

### 보호(Protection)

모든 주소는 페이지 테이블을 경유하므로, 테이블을 이용해서 보호 기능을 수행할 수 있다.

대표적으로 페이지 테이블마다 r(read), w(write), x(execute) 비트를 두어, 해당 비트가 켜져있을 때 그 수행이 가능하도록한다.


### 공유(Sharing)


공유는 메모리 낭비를 방지하기 위함이다. 같은 프로그램을 쓰는 복수 개의 프로세스가 있다면, 

프로세스의 메모리는 code + data + stack 영역으로 나뉘는데 프로그램이 같다면 code 영역은 같을 것이다. 

그러므로 하나의 code 영역을 복수 개의 프로세스가 공유하여 메모리 낭비를 줄이는 것이다.

단, code가 공유되려면 code가 변하지 않는 프로그램이어야 한다. 이를 non-self-modifying code = reentrant code(재진입가능 코드) = pure code 라고 한다.


> 출처 : https://velog.io/@codemcd/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9COS-13.-%ED%8E%98%EC%9D%B4%EC%A7%95
